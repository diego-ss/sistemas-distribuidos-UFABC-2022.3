package application;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

import application.Message.MessageType;


public class Server {

	ServerSocket serverSocket;
	InetAddress ip;
	Integer port;
	Integer leaderPort;
	
	Map<String, LocalDateTime> register = new HashMap<String, LocalDateTime>();
	
	
	
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}
	
	private void createSocket() {
		Thread th = new Thread(() -> {
			// canal de comunicação não orientado à conexão
			serverSocket = null;
			try {
				serverSocket = new ServerSocket(port);
			} catch (SocketException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			//System.out.println("Peer inicializado.");

			while (true && serverSocket != null) {
				// buffer de recebimento
				byte[] recBuffer = new byte[1024];
				// datagrama que será recebido
				DatagramPacket recPacket = new DatagramPacket(recBuffer, recBuffer.length);

				try {
					// recebendo pacote
					serverSocket.receive(recPacket);
					String informacao = new String(recPacket.getData(), recPacket.getOffset(), recPacket.getLength());
					// mensagem recebida no pacote
					Message message = Message.fromJson(informacao);
					// verifica se a mensagem já não foi tratada
					if (receivedMessagesControl.stream().anyMatch(m -> m.getId().equals(message.getId())))
						continue;
						
					receivedMessagesControl.add(message);

					// criando mensagem de resposta
					Message responseMessage = new Message();
					
					// Se é uma mensagem de busca...
					if (message.getType() == MessageType.SEARCH) {
						// verifica se o arquivo existe no diretório
						Boolean fileExists = fileExistsInFolder(message.getContent());
						// se existe, envia para o peer de origem
						if (fileExists) {
							answerToOriginPeer(message);
							// remove a mensagem da lista de tratadas depois de um tempo
							Timer tempTimer = new Timer();
							tempTimer.schedule(new TimerTask() {
								@Override
								public void run() {
									receivedMessagesControl.remove(message);
									tempTimer.cancel();
								}}, 0, 1000);
						} else {
							// se não existe, passa para os vizinhos
							forwardMessageToNeighbor(message);
						}
					}
					// se é uma mensagem de resposta, apenas printa e faz gestão da fila de mensagens enviadas
					else {
						String responseText = String.format("Peer com o arquivo procurado: %s:%s %s",
								recPacket.getAddress(), recPacket.getPort(), message.getContent());
						System.out.println(responseText);
						sentMessagesControl.remove(message);
					}

				} catch (IOException e) {
					if(!e.getMessage().toUpperCase().equals("Socket Closed".toUpperCase()))
						e.printStackTrace();
				}
			}
		});

		th.start();
	}

}
